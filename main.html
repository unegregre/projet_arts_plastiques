<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
        <title>three.js tutorial</title>
        <canvas id="c"></canvas>
		<style>
			body { margin: 0; 
                    overflow:hidden;}
            canvas { display: block;
                    width: 100%;
                    height: 100%; }
		</style>
	</head>
	<body>
        <script src="js/three.js"></script>
        <!--    X = red
                Y = green
                Z = blue
        -->
		<script type="module">
            import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/build/three.module.js';
            import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/controls/OrbitControls.js';
            import {OBJLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/loaders/OBJLoader.js';
            
            var canvas;
            var renderer;
            var camera, scene;

            const AMOUNT = 3;

            init();
            animate();

            function init() {
                const fov = 45;
                const near = 0.1;
                const far = 100;

                var ASPECT_RATIO = window.innerWidth / window.innerHeight;
                var WIDTH = ( window.innerWidth / 3 ) * window.devicePixelRatio;
                var HEIGHT = ( window.innerHeight / 2 ) * window.devicePixelRatio;

                canvas = document.querySelector('#c');
                renderer = new THREE.WebGLRenderer({canvas});
                renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight);

				var cameras = [];
                var subcamera;
                // cam 1
                subcamera = new THREE.PerspectiveCamera( fov, ASPECT_RATIO, near, far );
                subcamera.viewport = new THREE.Vector4( Math.floor( 0 ), Math.floor( 0 ), Math.ceil( WIDTH*2 ), Math.ceil( HEIGHT*2 ) );
                subcamera.position.x = 0;
                subcamera.position.y = 10 ;
                subcamera.position.z = -20;
                subcamera.lookAt( 0, 2, 0 );
                subcamera.autorotate
                subcamera.updateMatrixWorld();
                cameras.push( subcamera );

                // cam 2
                subcamera = new THREE.PerspectiveCamera( fov, ASPECT_RATIO, near, far );
                subcamera.viewport = new THREE.Vector4( Math.floor( 2*WIDTH ), Math.floor( HEIGHT ), Math.ceil( WIDTH ), Math.ceil( HEIGHT ) );
                subcamera.position.x = 12;
                subcamera.position.y = 7;
                subcamera.position.z = -12;
                subcamera.lookAt( 0, 2, 0 );
                subcamera.updateMatrixWorld();
                cameras.push( subcamera );

                // cam 3
                subcamera = new THREE.PerspectiveCamera( fov, ASPECT_RATIO, near, far );
                subcamera.viewport = new THREE.Vector4( Math.floor( 2*WIDTH ), Math.floor( 0 ), Math.ceil( WIDTH ), Math.ceil( HEIGHT ) );
                subcamera.position.x = -12;
                subcamera.position.y = 7;
                subcamera.position.z = 12;
                subcamera.lookAt( 0, 3, 0 );
                subcamera.updateMatrixWorld();
                cameras.push( subcamera );

				camera = new THREE.ArrayCamera( cameras );
				camera.position.z = 3;

                const controls = new OrbitControls(camera.cameras[0], canvas);
                controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.1;

				// controls.screenSpacePanning = false;

				// controls.minDistance = 100;
				// controls.maxDistance = 500;

				// controls.maxPolarAngle = Math.PI / 2;
                controls.target.set(0, 2.5, 0);
                controls.update();


                // var path = "./texture/";
				// var format = '.jpg';
				// var urls = [
				// 	path + 'wall' + format, path + 'wall' + format,
                //     path + 'wall' + format, path + 'wall' + format,
                //     path + 'wall' + format, path + 'wall' + format
				// ];

				// var textureCube = new THREE.CubeTextureLoader().load( urls );

				scene = new THREE.Scene();
				scene.background = new THREE.Color('black');
                

                scene.add(new THREE.AxisHelper(10));


                // PiÃ©destal
                {
                    const boxSize = 40;

                    const loader = new THREE.TextureLoader();
                    const texture = loader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.magFilter = THREE.NearestFilter;
                    const repeats = boxSize / 2;
                    texture.repeat.set(repeats, repeats);

                    const boxGeo = new THREE.BoxGeometry();
                    const boxMat = new THREE.MeshPhongMaterial({
                    side: THREE.DoubleSide,
                    });
                    const mesh = new THREE.Mesh(boxGeo, boxMat);
                    mesh.scale.set(8,8,8);
                    mesh.position.set(0,-4,0);
                    mesh.rotation.x = Math.PI * -.5;
                    scene.add(mesh);
                }

                // Room/skybox
                {

                    const roomGeo = new THREE.BoxGeometry();

                    const loader = new THREE.TextureLoader();
                
                    const materials = [
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/wall2.jpg'),
                            side: THREE.BackSide
                            }),
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/wall2.jpg'),
                            side: THREE.BackSide
                            }),
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/wall.jpg'),
                            side: THREE.BackSide
                            }),
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/wall.jpg'),
                            side: THREE.BackSide
                            }),
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/ground.jpg'),
                            side: THREE.BackSide
                            }),
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/ground.jpg'),
                            side: THREE.BackSide
                            }),
                    ];
                    const roombox = new THREE.Mesh(roomGeo, materials);
                    roombox.scale.set(60,60,40);
                    roombox.position.set(0,12,0);
                    roombox.rotation.x = Math.PI * -.5;
                    scene.add(roombox);
                }

                // sky ???
                {
                    const skyColor = 0xB1E1FF;  // light blue
                    const groundColor = 0xB97A20;  // brownish orange
                    const intensity = 1;
                    const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
                    scene.add(light);
                }

                // Light
                {
                    const color = 0xFFFFFF;
                    const intensity = 1;
                    const light = new THREE.DirectionalLight(color, intensity);
                    light.position.set(0, 10, 0);
                    light.target.position.set(-5, 0, 0);
                    scene.add(light);
                    scene.add(light.target);
                }

                // Teapot
                {
                    const teapotMat = new THREE.MeshStandardMaterial ({
                        side: THREE.DoubleSide,
                        color: 0xff0000,
                    });
                    const objLoader = new OBJLoader();
                    var path = './mesh/newell_teaset/teapot.obj';
                    // objLoader.setMaterials(teapotMat);
                    objLoader.load(path, (root) => {
                        root.rotation.y = Math.PI * 0.12;
                        root.materials = teapotMat;
                        scene.add(root);
                    });
                }

                window.addEventListener( 'resize', onWindowResize, false );
            } 

            function resizeRendererToDisplaySize(renderer) {
                const canvas = renderer.domElement;
                const width = window.innerWidth;
                const height = window.innerHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if (needResize) {
                renderer.setSize(width, height, false);
                }
                return needResize;
            }

            function onWindowResize() {

                var ASPECT_RATIO = window.innerWidth / window.innerHeight;
                var WIDTH = ( window.innerWidth / 3 ) * window.devicePixelRatio;
                var HEIGHT = ( window.innerHeight / 2 ) * window.devicePixelRatio;

                var subcamera;

                camera.aspect = ASPECT_RATIO;
                camera.updateProjectionMatrix();

                // cam 1
                subcamera = camera.cameras[ 0 ];
                subcamera.viewport.set(
                    Math.floor( 0 ),
                    Math.floor( 0 ),
                    Math.ceil( 2*WIDTH ),
                    Math.ceil( 2*HEIGHT )
                );
                subcamera.aspect = ASPECT_RATIO;
                subcamera.updateProjectionMatrix();  

                // cam 2
                subcamera = camera.cameras[ 2 ];
                subcamera.viewport.set(
                    Math.floor( 2*WIDTH ), 
                    Math.floor( HEIGHT ), 
                    Math.ceil( WIDTH ), 
                    Math.ceil( HEIGHT )
                );
                subcamera.aspect = ASPECT_RATIO;
                subcamera.updateProjectionMatrix();

                // cam 3
                subcamera = camera.cameras[ 1 ];
                subcamera.viewport.set(
                    Math.floor( 2*WIDTH ), 
                    Math.floor( 0 ), 
                    Math.ceil( WIDTH ), 
                    Math.ceil( HEIGHT )
                );
                subcamera.aspect = ASPECT_RATIO;
                subcamera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function animate() {

                renderer.render( scene, camera );

                requestAnimationFrame( animate );

            }

		</script>
	</body>
</html>