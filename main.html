<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
        <title>three.js tutorial</title>
        <canvas id="c"></canvas>
		<style>
			body { margin: 0; 
                    overflow:hidden;}
            canvas { display: block;
                    width: 100%;
                    height: 100%; }
		</style>
	</head>
	<body>

        

        <script src="js/three.js"></script>
        <!--    X = red
                Y = green
                Z = blue
        -->

        <script id="fragmentShader" type="x-shader/x-fragment">

			uniform float time;

			varying vec2 vUv;

			void main(void) {

				vec2 p = - 1.0 + 2.0 * vUv;
				float a = time * 40.0;
				float d, e, f, g = 1.0 / 40.0 ,h ,i ,r ,q;

				e = 400.0 * ( p.x * 0.5 + 0.5 );
				f = 400.0 * ( p.y * 0.5 + 0.5 );
				i = 200.0 + sin( e * g + a / 150.0 ) * 20.0;
				d = 200.0 + cos( f * g / 2.0 ) * 18.0 + cos( e * g ) * 7.0;
				r = sqrt( pow( abs( i - e ), 2.0 ) + pow( abs( d - f ), 2.0 ) );
				q = f / r;
				e = ( r * cos( q ) ) - a / 2.0;
				f = ( r * sin( q ) ) - a / 2.0;
				d = sin( e * g ) * 176.0 + sin( e * g ) * 164.0 + r;
				h = ( ( f + d ) + a / 2.0 ) * g;
				i = cos( h + r * p.x / 1.3 ) * ( e + e + a ) + cos( q * g * 6.0 ) * ( r + h / 3.0 );
				h = sin( f * g ) * 144.0 - sin( e * g ) * 212.0 * p.x;
				h = ( h + ( f - e ) * q + sin( r - ( a + h ) / 7.0 ) * 10.0 + i / 4.0 ) * g;
				i += cos( h * 2.3 * sin( a / 350.0 - q ) ) * 184.0 * sin( q - ( r * 4.3 + a / 12.0 ) * g ) + tan( r * g + h ) * 184.0 * cos( r * g + h );
				i = mod( i / 5.6, 256.0 ) / 64.0;
				if ( i < 0.0 ) i += 4.0;
				if ( i >= 2.0 ) i = 4.0 - i;
				d = r / 350.0;
				d += sin( d * d * 8.0 ) * 0.52;
				f = ( sin( a * g ) + 1.0 ) / 2.0;
				gl_FragColor = vec4( vec3( f * i / 1.6, i / 2.0 + d / 13.0, i ) * d * p.x + vec3( i / 1.3 + d / 8.0, i / 2.0 + d / 18.0, i ) * d * ( 1.0 - p.x ), 1.0 );

			}

		</script>

        <script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>

		<script type="module">
            import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/build/three.module.js';
            import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/controls/OrbitControls.js';
            import {OBJLoader2} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/loaders/OBJLoader2.js';
            import { MTLLoader } from "https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/loaders/MTLLoader.js";
            import { MtlObjBridge } from "https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/loaders/obj2/bridge/MtlObjBridge.js";

            import Stats from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/libs/stats.module.js';

            const scope = this;
            var canvas;
            var renderer;
            var camera, scene;
            var uniforms;

            var stats, clock, uniforms;

            const AMOUNT = 3;

            init();
            animate();

            function init() {
                const fov = 45;
                const near = 0.1;
                const far = 100;

                var ASPECT_RATIO = window.innerWidth / window.innerHeight;
                var WIDTH = ( window.innerWidth / 3 ) * window.devicePixelRatio;
                var HEIGHT = ( window.innerHeight / 2 ) * window.devicePixelRatio;

                canvas = document.querySelector('#c');
                renderer = new THREE.WebGLRenderer({canvas});
                renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight);

                stats = new Stats();
				canvas.appendChild( stats.dom );

				var cameras = [];
                var subcamera;
                // cam 1
                subcamera = new THREE.PerspectiveCamera( fov, ASPECT_RATIO, near, far );
                subcamera.viewport = new THREE.Vector4( Math.floor( 0 ), Math.floor( 0 ), Math.ceil( WIDTH*2 ), Math.ceil( HEIGHT*2 ) );
                subcamera.position.x = 0;
                subcamera.position.y = 10 ;
                subcamera.position.z = -20;
                subcamera.lookAt( 0, 2, 0 );
                subcamera.autorotate
                subcamera.updateMatrixWorld();
                cameras.push( subcamera );

                // cam 2
                subcamera = new THREE.PerspectiveCamera( fov, ASPECT_RATIO, near, far );
                subcamera.viewport = new THREE.Vector4( Math.floor( 2*WIDTH ), Math.floor( HEIGHT ), Math.ceil( WIDTH ), Math.ceil( HEIGHT ) );
                subcamera.position.x = 12;
                subcamera.position.y = 7;
                subcamera.position.z = -12;
                subcamera.lookAt( 0, 2, 0 );
                subcamera.updateMatrixWorld();
                cameras.push( subcamera );

                // cam 3
                subcamera = new THREE.PerspectiveCamera( fov, ASPECT_RATIO, near, far );
                subcamera.viewport = new THREE.Vector4( Math.floor( 2*WIDTH ), Math.floor( 0 ), Math.ceil( WIDTH ), Math.ceil( HEIGHT ) );
                subcamera.position.x = -12;
                subcamera.position.y = 7;
                subcamera.position.z = 12;
                subcamera.lookAt( 0, 3, 0 );
                subcamera.updateMatrixWorld();
                cameras.push( subcamera );

				camera = new THREE.ArrayCamera( cameras );
				camera.position.z = 3;

                const controls = new OrbitControls(camera.cameras[0], canvas);
                controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.1;

				// controls.screenSpacePanning = false;

				// controls.minDistance = 100;
				// controls.maxDistance = 500;

				// controls.maxPolarAngle = Math.PI / 2;
                controls.target.set(0, 2.5, 0);
                controls.update();


                // var path = "./texture/";
				// var format = '.jpg';
				// var urls = [
				// 	path + 'wall' + format, path + 'wall' + format,
                //     path + 'wall' + format, path + 'wall' + format,
                //     path + 'wall' + format, path + 'wall' + format
				// ];

				// var textureCube = new THREE.CubeTextureLoader().load( urls );

				scene = new THREE.Scene();
				scene.background = new THREE.Color('black');
                

                scene.add(new THREE.AxisHelper(10));

                clock = new THREE.Clock();

                uniforms = {
					"time": { value: 1.0 }
				};


                // Pi√©destal
                {
                    const boxSize = 40;

                    const loader = new THREE.TextureLoader();
                    const texture = loader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.magFilter = THREE.NearestFilter;
                    const repeats = boxSize / 2;
                    texture.repeat.set(repeats, repeats);

                    const boxGeo = new THREE.BoxGeometry();
                    const boxMat = new THREE.MeshPhongMaterial({
                        side: THREE.DoubleSide,
                        color : 0xffffff,
                    });
                    const mesh = new THREE.Mesh(boxGeo, boxMat);
                    mesh.scale.set(8,8,8);
                    mesh.position.set(0,-4,0);
                    mesh.rotation.x = Math.PI * -.5;
                    scene.add(mesh);
                }

                // Room/skybox
                {

                    const roomGeo = new THREE.BoxGeometry();

                    const loader = new THREE.TextureLoader();
                
                    const materials = [
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/wall2.jpg'),
                            side: THREE.BackSide
                            }),
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/wall2.jpg'),
                            side: THREE.BackSide
                            }),
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/wall.jpg'),
                            side: THREE.BackSide
                            }),
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/wall.jpg'),
                            side: THREE.BackSide
                            }),
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/ground.jpg'),
                            side: THREE.BackSide
                            }),
                        new THREE.MeshPhongMaterial({
                            map: loader.load('texture/ground.jpg'),
                            side: THREE.BackSide
                            }),
                    ];
                    const roombox = new THREE.Mesh(roomGeo, materials);
                    roombox.scale.set(60,60,40);
                    roombox.position.set(0,12,0);
                    roombox.rotation.x = Math.PI * -.5;
                    scene.add(roombox);
                }

                // sky ???
                {
                    const skyColor = 0xB1E1FF;  // light blue
                    const groundColor = 0xB97A20;  // brownish orange
                    const intensity = 1;
                    const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
                    scene.add(light);
                }

                // Light
                {
                    const color = 0xFFFFFF;
                    const intensity = 1;
                    const light = new THREE.DirectionalLight(color, intensity);
                    light.position.set(0, 10, 0);
                    light.target.position.set(-5, 0, 0);
                    scene.add(light);
                    scene.add(light.target);
                }

                // Teapot
                {
                    const shaderMat = new THREE.ShaderMaterial( {

                        uniforms: uniforms,
                        vertexShader: document.getElementById( 'vertexShader' ).textContent,
                        fragmentShader: document.getElementById( 'fragmentShader' ).textContent
                    } );
                    const teapotMat = new THREE.MeshPhongMaterial ({
                        side: THREE.DoubleSide,
                        color: 0x8888cc,

                        emissive: 0x000033,
                        shininess: 90,
                        specular: 0xff00ff,
                        reflectivity: 0.5,
                        opacity: 0.8,
                        transparent: true
                        // metalness: 0.8,
                        // roughness: 0.5,
                        // wireframe: true,
                    });
        
                    var path = './mesh/newell_teaset/teapot.obj';
                    var modelName = 'teapot';

                    const objLoader = new OBJLoader2();
                    const callbackOnLoad = function ( object3d ) {

                        scene.add( object3d );
                        console.log( 'Loading complete: ' + modelName );

                    };

                    objLoader.setModelName( modelName );
                    objLoader.addMaterials( shaderMat);
                    objLoader.load( path, 
                        function( obj ){
                            obj.rotation.y = Math.PI * 0.12;
                            obj.traverse( function( child ) {
                                if ( child instanceof THREE.Mesh ) {
                                    child.material = shaderMat;
                                }
                            } );
                            scene.add( obj );
                        },
                        function( xhr ){
                            console.log( (xhr.loaded / xhr.total * 100) + "% loaded")
                        },
                        function( err ){
                            console.error( "Error loading 'ship.obj'")
                        }
                    );
                }

                window.addEventListener( 'resize', onWindowResize, false );
            } 

            function resizeRendererToDisplaySize(renderer) {
                const canvas = renderer.domElement;
                const width = window.innerWidth;
                const height = window.innerHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if (needResize) {
                renderer.setSize(width, height, false);
                }
                return needResize;
            }

            function onWindowResize() {

                var ASPECT_RATIO = window.innerWidth / window.innerHeight;
                var WIDTH = ( window.innerWidth / 3 ) * window.devicePixelRatio;
                var HEIGHT = ( window.innerHeight / 2 ) * window.devicePixelRatio;

                var subcamera;

                camera.aspect = ASPECT_RATIO;
                camera.updateProjectionMatrix();

                // cam 1
                subcamera = camera.cameras[ 0 ];
                subcamera.viewport.set(
                    Math.floor( 0 ),
                    Math.floor( 0 ),
                    Math.ceil( 2*WIDTH ),
                    Math.ceil( 2*HEIGHT )
                );
                subcamera.aspect = ASPECT_RATIO;
                subcamera.updateProjectionMatrix();  

                // cam 2
                subcamera = camera.cameras[ 2 ];
                subcamera.viewport.set(
                    Math.floor( 2*WIDTH ), 
                    Math.floor( HEIGHT ), 
                    Math.ceil( WIDTH ), 
                    Math.ceil( HEIGHT )
                );
                subcamera.aspect = ASPECT_RATIO;
                subcamera.updateProjectionMatrix();

                // cam 3
                subcamera = camera.cameras[ 1 ];
                subcamera.viewport.set(
                    Math.floor( 2*WIDTH ), 
                    Math.floor( 0 ), 
                    Math.ceil( WIDTH ), 
                    Math.ceil( HEIGHT )
                );
                subcamera.aspect = ASPECT_RATIO;
                subcamera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function animate() {

                renderer.render( scene, camera );

                requestAnimationFrame( animate );

                stats.update();

                const delta = clock.getDelta();

				uniforms[ "time" ].value += delta * 5;

            }

            

		</script>
	</body>
</html>